# コーディングルール

このドキュメントはプロジェクトで守るべきコーディングルールです。

## 変数

- **必ず** `const` を**最優先で使うこと**。は条件付き代入やループでの再代入が必要な場合は `let`を使用してもよい。

## 反復処理

- 配列の反復には**必ず** `Array.prototype.map`、`filter`、`reduce`、`some`、`every`、`find`、`flatMap` などの**配列メソッド（イテレータ関数）を最優先で使うこと**。
- `for`、`for...of`、`forEach` の使用および配列メソッド（イテレータ関数）の多重ネストは**原則禁止**とする。ただしパフォーマンスや副作用が明確に必要な場合のみ、**例外的に専用関数に分離して使うこと**。
  - パフォーマンスが重要な大量データ処理（例：数千件以上のデータ変換、seed処理など）する場合。
  - 高階関数では中間配列の大量生成によりメモリ効率が著しく悪化する場合。

## オブジェクト操作

- 条件チェック内でのオブジェクト変更（副作用）は**禁止**する。条件チェックと代入は明確に分離すること。
  - 例：

    ```typescript
    // 推奨
    const filters: Record<string, unknown> = {};
    if (name) {
      filters.name = { contains: name };
    }

    // 非推奨
    if (name && (filters.name = { contains: name })) {
      /* 処理 */
    }
    ```

## React

### パフォーマンス最適化フック（`useMemo` / `useCallback`）

#### 原則

- **`useMemo` と `useCallback` は原則禁止とする。**
- 理由：
  - 適切に使わないとバグ（stale closure等）の温床になる
  - 効果が不明確なまま乱用すると逆にパフォーマンス低下の原因になる
  - 可読性・保守性を下げる

#### 例外的に使用を許可する条件

1. パフォーマンス測定（プロファイリング）により、関数や計算が**実際のボトルネック**であることを確認している
2. 最適化の効果を**定量的に測定**し、改善が確認できている
3. コードレビューで**妥当性が承認**されている

#### 優先すべき基本的な最適化

- コンポーネントの適切な分割
- 不要な再レンダリングの原因を取り除く
- 重い処理を可能な限りサーバーサイドに移動
- `React.memo` の適切な使用（こちらも慎重に検討）

#### 使用しないケース

- 小さなイベントハンドラを内部で使うだけ
- propsで渡さない関数やオブジェクト
- 再レンダーを気にして安易に包むだけ
- 計算コストが軽い処理

```tsx
// 非推奨
const handleClick = useCallback(() => setCount(count + 1), [count]);
```

#### 使用してよいケース

- 子コンポーネントに渡す関数で、子が `React.memo` されており、かつ再レンダーが問題になる場合
- 高コストな計算結果をキャッシュして表示する場合
- useEffectの依存配列に関数やオブジェクトを渡す必要がある場合
- 上記で必ずパフォーマンス測定により改善が確認されていること

```tsx
// 推奨（条件を満たす場合のみ）
const expensiveValue = useMemo(() => computeHeavyData(data), [data]);

const memoizedFn = useCallback(() => {
  onChildUpdate(expensiveValue);
}, [onChildUpdate, expensiveValue]);
```

#### 注意点

- stateに依存する関数を無理に `useCallback` で包むと**stale closureバグ**が起きやすい
- 乱用は可読性・保守性を下げるだけでなく、パフォーマンス低下の原因にもなる
- 本当に必要な場面のみ、**測定・レビューを経て使用**する
